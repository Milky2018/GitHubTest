---
description: 2019年1月17日
---

# 第六章：泛型和ASM

作为一个先接触 C++ 再接触 Java 的学生，初见 Java 的泛型时，我感觉既熟悉又陌生。最初，我看见 Java 作为面向对象语言对于“引用类型”的考虑已经很成熟了，以至于 Java 绝不会像 C++ 那样因为 Template 的使用导致代码膨胀。另一方面，“在泛型代码内部无法获得任何有关泛型参数类型的信息这个”必然后果的到来让人头痛不已。

当然，我的所谓头痛并不是因为在代码开发过程中被它困扰，而是一种来自一个不写代码只读代码的为程序员的对程序设计语言的审美。这种审美没什么价值，但相较于最初接触 Java 时曾幻想它是完美的、能够自圆其说的语言的我来说，Java SE5 带来的这个变化让 Java 真正意义上不再那么纯粹了，更不用提后来的 lambda 表达式等等。

我所想说的是，“泛型”这个特性在使用容器时看起来是很自然而且至关重要的，否则容器中的对象先自动向上转型为 Object，需要时再手动向下转型这种现象就会永存，既不自然，也不安全。但除了容器之外呢？程序员都能理解“参数化类型”在面向对象设计中的意义吗？泛型能够做的事情是不是应该有所限制？Java 在一次一次的更新中能控制住自己吗？它会变得和 C++ 一样吗？

也许，这就是进步的代价吧，Java 的长寿证明了一切。

关于这一章，我打算深究 fastjson 的反序列化器对于泛型处理部分的代码后再撰写。之所以要将泛型和 ASM 一起提出，是因为如果 fastjson 没有使用 ASM 技术，这部分代码的难度将会降低一半（当然，反序列化的速度可能也会降低一半）。而且，fastjson 中使用的 ASM 不止一次被诟病，比较典型的是：在一个类型中封装了另一个有同名字段或方法的对象，就会导致 ASM 解析过程中的出错。这个问题直至我阅读的 1.2.49 版本都没有修复。

所以，为了避免这个问题，以及简化反序列化器的逻辑，我一般会使用以下代码：

```java
ParserConfig.getGlobalInstance().setAsmEnable(false);
```



