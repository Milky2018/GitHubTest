---
description: 2019年1月17日
---

# 第六章：泛型和ASM

关于这一章，我打算深究 fastjson 的反序列化器对于泛型处理部分的代码后再撰写。

作为一个先接触 C++ 再接触 Java 的学生，初见 Java 的泛型时，我感觉既熟悉又陌生。最初，我看见 Java 作为面向对象语言对于“引用类型”的考虑已经很成熟了，以至于 Java 绝不会像 C++ 那样因为 Template 的使用导致代码膨胀。另一方面，“在泛型代码内部无法获得任何有关泛型参数类型的信息这个”必然后果的到来让人头痛不已。

当然，我的所谓头痛并不是因为在代码开发过程中被它困扰，而是一种来自一个不写代码只读代码的为程序员的对程序设计语言的审美。这种审美没什么价值，但相较于最初接触 Java 时曾幻想它是完美的、能够自圆其说的语言的我来说，Java SE5 带来的这个变化让 Java 真正意义上不再那么纯粹了，更不用提后来的 lambda 表达式等等。

我所想说的是，“泛型”这个特性在使用容器时看起来是很自然而且至关重要的，否则容器中的对象先自动向上转型为 Object，需要时再手动向下转型这种现象就会永存，既不自然，也不安全。但除了容器之外呢？程序员都能理解“参数化类型”在面向对象设计中的意义吗？泛型能够做的事情是不是应该有所限制？Java 在一次一次的更新中能控制住自己吗？它会变得和 C++ 一样吗？

也许，这就是进步的代价吧，Java 的长寿证明了一切。

之所以要将泛型和 ASM 一起提出，是因为如果 fastjson 没有使用 ASM 技术，这部分代码的难度将会降低一半（当然，反序列化的速度可能也会降低一半）。而且，fastjson 中使用的 ASM 不止一次被诟病，比较典型的是：在一个类型中封装了另一个有同名字段或方法的对象，就会导致 ASM 解析过程中的出错。这个问题直至我阅读的 1.2.49 版本都没有修复。

所以，为了避免这个问题，以及简化反序列化器的逻辑，我一般会使用以下代码：

```java
ParserConfig.getGlobalInstance().setAsmEnable(false);
```

ASM 能够通过改造既有类，直接生成需要的代码。增强的代码是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。最直接的改造 Java 类的方法莫过于直接改写 class 文件。Java 规范详细说明了 class 文件的格式，直接编辑字节码确实可以改变 Java 类的行为。直到今天，还有一些 Java 高手们使用最原始的工具，如 UltraEdit 这样的编辑器对 class 文件动手术。是的，这是最直接的方法，但是要求使用者对 Java class 文件的格式了熟于心：小心地推算出想改造的函数相对文件首部的偏移量，同时重新计算 class 文件的校验码以通过 Java 虚拟机的安全机制。

不幸的是，我并不是高手，所以看到 fastjson 用 ASM 来提高解析效率时，我的第一反应就是“不靠谱”。人总是对自己不能控制的东西充满恐惧，程序员犹是如此。

最后，对于泛型，我可能在以后的策略模式讨论章节再次提到。策略模式是我认真研究的第一个设计模式，它简单、自然，但让我吃了不少苦头。我经常考虑，如果语言支持直接将某个函数直接当作行为本身，而不是为这个行为再设计对象（Java 中 inteface 的正常用法），策略模式的实现是否会显得更优雅？

事实上，大多数语言都是支持以上这种机制的：所有函数式语言都支持，C++ 有基于括号操作符重载的仿函数，JavaScript 中的函数属于引用类型，就连传统的 C 可以直接将函数指针当作“对象”，golang 更是摆脱了这方面的束缚……而之所以我会说在这里我将再次提到“泛型”，就是因为基于泛型，Java 有了和仿函数很相似的“函数对象”，这就是我在前面提到的泛型的更强大的作用。我想我会用函数对象写一个看起来很漂亮的策略模式案例，然后重新对泛型报以谨慎的态度。

